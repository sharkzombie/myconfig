;; -*- mode: emacs-lisp -*-

(setq viper-inhibit-startup-message  't)
(setq viper-expert-level 5)
(setq viper-translate-all-ESC-keysequences nil)
(setq viper-vi-style-in-minibuffer t)
;(setq viper-SEP-char-class " -)")
(viper-buffer-search-enable)
(setq viper-change-deletes t)
(setq viper-ESC-keyseq-timeout 100)
(setq-default viper-auto-indent t)
(setq-default viper-ex-style-editing nil)
(setq-default viper-syntax-preference 'emacs)

;; allow using below for the prefix keys
(define-key viper-vi-basic-map ";" (make-sparse-keymap))
(define-key viper-vi-basic-map "z" (make-sparse-keymap))
(define-key viper-vi-basic-map "Z" nil)
(define-key viper-vi-basic-map "q" (make-sparse-keymap))
(define-key viper-vi-basic-map "Q" 'viper-nil)
(define-key viper-vi-basic-map "," (make-sparse-keymap))
(define-key viper-vi-basic-map ";c" 'comment-dwim)
(define-key viper-vi-basic-map "zz" nil)
(define-key viper-vi-basic-map "\C-c\C-g" nil)

;; Ok this space finishes EX command shit is just evil
;; or not.. It has to have it so it knows to turn completion
;; on for file related commands

;; (define-key viper-ex-cmd-map " "  'self-insert-command)
;; (define-key viper-ex-cmd-map "\t" 'ex-cmd-complete)

;; I'm not using C-u and C-y Vi command mode
(define-key viper-vi-global-user-map "\C-u" 'universal-argument)

;; Taking the plunge, screw viper's half-assed search
;; (define-key viper-vi-basic-map "/" 'isearch-forward-regexp)
;; (define-key viper-vi-basic-map "?" 'isearch-backward-regexp)
;; (define-key viper-vi-basic-map "n" 'isearch-repeat-forward)
;; (define-key viper-vi-basic-map "N" 'isearch-repeat-backward)

;; cut-n-paste
;; (define-key viper-vi-basic-map "\C-V" 'yank)
;; (define-key viper-insert-basic-map "\C-V" 'yank)
;; (define-key viper-insert-basic-map "\C-N" 'dabbrev-expand)

;; undefine S-tab
(define-key viper-insert-basic-map [S-tab] nil)
(define-key viper-insert-basic-map [delete] nil)
(define-key viper-insert-basic-map [deletechar] nil)
;; undefine C-c / because its used in org-mode globally
(define-key viper-vi-basic-map "\C-c/" nil)

(require 'advice)
;; (defadvice viper-undo (around viper-undo-more-maybe activate) 
;;   "Have `viper-undo' behave more like Vim." 
;;   (if (eq last-command 'viper-undo) 
;;       (viper-undo-more) 
;;     ad-do-it)) 

;; do not adjust undo, so that inserting something, then moving around
;; and then inserting again generates 2 undo commands instead of one.
;; (defun viper-adjust-undo ()
;;   "Redefined to empty function so that movement commands with cursor break the undo list"
;;   )

(define-key viper-vi-basic-map "u" 'undo)

(defun my-envelop-ESC-key ()
  (let ((event last-input-event)
        (keyseq [nil])
        (inhibit-quit t))
    (if (eql event ?\e)
        (progn
          (if t
              (progn
                (let (minor-mode-map-alist emulation-mode-map-alists)
                  (viper-set-unread-command-events event)
                  (setq keyseq (read-key-sequence 
                                nil 'continue-echo 'no-lower-case))
                                        ;(message "Keyseq = %s" keyseq)

                  )                     ; let
                ;; If keyseq translates into something that still has ESC
                ;; at the beginning, separate ESC from the rest of the seq.
                ;; In XEmacs we check for events that are keypress meta-key
                ;; and convert them into [escape key]
                ;;
                ;; This is needed for the following reason:
                ;; If ESC is the first symbol, we interpret it as if the
                ;; user typed ESC and then quickly some other symbols.
                ;; If ESC is not the first one, then the key sequence
                ;; entered was apparently translated into a function key or
                ;; something (e.g., one may have
                ;; (define-key function-key-map "\e[192z" [f11])
                ;; which would translate the escape-sequence generated by
                ;; f11 in an xterm window into the symbolic key f11.
                ;;
                ;; If `first-key' is not an ESC event, we make it into the
                ;; last-command-event in order to pretend that this key was
                ;; pressed.  This is needed to allow arrow keys to be bound to
                ;; macros.  Otherwise, viper-exec-mapped-kbd-macro will think
                ;; that the last event was ESC and so it'll execute whatever is
                ;; bound to ESC. (Viper macros can't be bound to
                ;; ESC-sequences).
                (unless (and (stringp keyseq)
                             (string= keyseq ""))
                  (let* ((first-key (elt keyseq 0))
                         (key-mod (event-modifiers first-key)))
                    (cond ((and (viper-ESC-event-p first-key)
                                (not viper-translate-all-ESC-keysequences))
                           ;; put keys following ESC on the unread list
                           ;; and return ESC as the key-sequence
                           (viper-set-unread-command-events (subseq keyseq 1))
                           (setq last-input-event event
			       keyseq (if (featurep 'emacs)
					  "\e"
					(vector (character-to-event ?\e)))))
                          ((and (featurep 'xemacs)
                                (key-press-event-p first-key)
                                (equal '(meta) key-mod))
                           (viper-set-unread-command-events
                            (vconcat (vector
                                      (character-to-event (event-key first-key)))
                                     (subseq keyseq 1)))
                           (setq last-input-event event
                                 keyseq (vector (character-to-event ?\e))))
                          ((eventp first-key)
                           (setq last-command-event
                                 (viper-copy-event first-key))))))) ; end progn

            ;; this is escape event with nothing after it
            ;; put in unread-command-event and then re-read
            (viper-set-unread-command-events event)
            (setq keyseq (read-key-sequence nil))))
      ;; not an escape event
      (setq keyseq (vector event)))
    keyseq))

;;;
;;; Support for overriding viper keys in major modes
;;;
(defun viper-override-key (mode state key function)

  "Override key binding in major mode while viper is
active. 

`state' parameter is name of viper state like 'insert-state or
'vi-state, or NIL in which case binding will be done in both insert
and vi states "

  (if state
      (let* 
          ((symb 
            (intern (format "%s-viper-%s-map" mode state)))
           (map (when (boundp symb)
                  (symbol-value symb))))
        (unless map
          (setq map (set symb (make-sparse-keymap)))
          (add-to-list 'viper-major-mode-modifier-list 
                       (list mode state symb) t))
        (define-key map key function))
    (viper-override-key mode 'vi-state key function)
    (viper-override-key mode 'insert-state key function)))

;; fix :q! not quitting

(defun ex-quit ()
  (let ((force nil)
        (kill-buffer-query-functions 
         (remove 'server-kill-buffer-query-function kill-buffer-query-functions)))
    (save-excursion
      (setq viper-ex-work-buf (get-buffer-create viper-ex-work-buf-name))
      (set-buffer viper-ex-work-buf)
      (when (looking-at "!")
        (forward-char 1)
        (setq force t)))
    (when force (set-buffer-modified-p nil))
    (kill-buffer (current-buffer))))

(defadvice ex-write (around dont-ask activate)
  "Don't ask about connected client" 
  (let ((kill-buffer-query-functions 
         (remove 'server-kill-buffer-query-function kill-buffer-query-functions)))
    ad-do-it))

;; don't want
(defun viper-maybe-checkout (buffer))
;; ditto
(defun viper-adjust-undo ())
(defun viper-set-complex-command-for-undo ())

(defun viper-convert-Q-to-q ()
  "I like Q in viper do what q did in emacs, unless it was self-insert-command"
  (interactive)
  (let* ((emulation-mode-map-alists
          (remove 'viper--key-maps
                  (remove 'viper--intercept-key-maps
                          emulation-mode-map-alists)))
         
         (minor-mode-map-alist
          (remove 'viper--key-maps
                  (remove 'viper--intercept-key-maps
                          minor-mode-map-alist)))
         (q (key-binding "q")))
    (if (not (eq q 'self-insert-command))
        (let ((last-command-event ?q))
          (call-interactively q)))))

(defadvice viper-put-back (before remember-window-start-like-yank activate)
  (setq yank-window-start (window-start)))

(defadvice viper-Put-back (before remember-window-start-like-yank activate)
  (setq yank-window-start (window-start)))
 
(defadvice yank-pop (around viper-fix-yank-pop activate)
  (let* ((is-viper (and (boundp 'viper-vi-basic-minor-mode) viper-vi-basic-minor-mode))
         (last-viper-cmd (when is-viper (car (ring-ref viper-command-ring 0)))))
    (if (not
         (and is-viper (memq last-viper-cmd '(viper-Put-back viper-put-back))))
        (setq ad-return-value ad-do-it)
      (if (viper-same-line (point) (mark))
          (progn
            (if (< (point) (mark))
              (exchange-point-and-mark)
              (viper-forward-char-carefully))))
      (setq ad-return-value ad-do-it)
      (if (viper-same-line (point) (mark))
          (or (= (point) (mark)) 
              (progn
                (when (< (point) (mark))
                  (exchange-point-and-mark))
                (viper-backward-char-carefully)))
        (when (> (point) (mark))
          (exchange-point-and-mark))
        (if (bolp)
            (back-to-indentation))))))

(defun viper-get-ex-address-subr (old-address dot)
  "This fixes :/one/;/two/d"
  (let ((address nil))
    (if (null old-address) (setq old-address dot))
    (cond ((eq ex-token-type 'dot)
	   (setq address dot))
	  ((eq ex-token-type 'add-number)
	   (save-excursion
	     (goto-char old-address)
	     (forward-line (if (= old-address 0) (1- ex-token) ex-token))
	     (setq address (point-marker))))
	  ((eq ex-token-type 'sub-number)
	   (save-excursion
	     (goto-char old-address)
	     (forward-line (- ex-token))
	     (setq address (point-marker))))
	  ((eq ex-token-type 'abs-number)
	   (save-excursion
	     (goto-char (point-min))
	     (if (= ex-token 0) (setq address 0)
	       (forward-line (1- ex-token))
	       (setq address (point-marker)))))
	  ((eq ex-token-type 'end)
	   (save-excursion
	     (goto-char (1- (point-max)))
	     (setq address (point-marker))))
	  ((eq ex-token-type 'plus) t)  ; do nothing
	  ((eq ex-token-type 'minus) t) ; do nothing
	  ((eq ex-token-type 'search-forward)
	   (save-excursion
             (when (eq prev-token-type 'semi-colon)
               (goto-char old-address))
	     (ex-search-address t)
	     (setq address (point-marker))))
	  ((eq ex-token-type 'search-backward)
	   (save-excursion
	     (ex-search-address nil)
	     (setq address (point-marker))))
	  ((eq ex-token-type 'goto-mark)
	   (save-excursion
	     (if (null ex-token)
		 (exchange-point-and-mark)
	       (goto-char
		(viper-register-to-point
		 (viper-int-to-char (1+ (- ex-token ?a))) 'enforce-buffer)))
	     (setq address (point-marker)))))
    address))

(defadvice viper-adjust-keys-for (after dont-bind-ctl-h activate)
  "I like to map C-h to my own stuff"
  (define-key viper-vi-basic-map "\C-h" nil)
  (define-key viper-insert-basic-map "\C-h" nil))
